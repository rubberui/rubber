# Rubber UI

Гипотеза, которую я бы хотел проверить, это полностью декларативный способ создания GUI приложений на Java, с полной совместимостью с другими JVM языками и поддержкой GraalVM, в коде верстки\макете, нет никакой логики, и является очень гибким, верстка возможна как и кодом, так и yaml, xml, rbml (Rubber Markup Language).

Изначально, гипотезу по подобному продукту, я хочу проверить на Desktop платформе, а позже, если это действительно может приглянуться сообществу, реализуем так же привязки к Android платформе. Технически, планируется использовать только Java, Skia.

Так же, rubber будет поддерживать только MVVM, так как я считаю его наиболее успешной идеей среди других, ну и просто, я его хорошо знаю%).

Основная цель фреймворка, не производительность (скорее всего не в этом дело будет), а именно качество кода продукта, и его поддержка.

Вы можете не соглашаться с моими идеями по поводу этой гипотезы\фреймворка, любые комментарии можете оставить в issue, я буду рад обсудить какие-либо вопросы.

## Примеры

Некоторые примеры могут быть на двух языках (Java, Kotlin), но технически, поддерживается любой JVM язык (или даже с GraalVM с FFI, еще больший спектр языков)

1. Приложение, которое на главном мониторе отрисует окно, которое будет выровнено по центру экрана, и которое будет иметь автоматически вычисленный размер, которое так же будет иметь заголовок "Hello World", так же которое будет иметь корневой компонент, который будет создан из home.yaml файла разметки, со стилями из home.css, и с вью моделью HomeViewModel. В это же приложение, мы передаем аргументы из main функции. И просто, запускаем эту всю шарманку `go()`. [Ссылка на пример - Java](./proto/001_Simple_application.java) • [Ссылка на пример - Kotlin](./proto/0011_Simple_application.kt)

2. Все тоже самое, что и в первом примере, но создание UI происходит именно в коде. Теперь контент (Content), внутри себя так же принимает остальные UI элементы, FlexBox, с двумя дочерними элементами, TextBlock, и Button, которые имеют StyleId (идентификатор стиля), так как стилизация может происходить не только в .css, а в любом другом еще формате (yaml к примеру). Так же устанавливаем Text для этих компонентов, внутри себя он может принимать не только String. А так же привязки, что свойственно для MVVM, к примеру, у TextBlock, есть FormattingBinding, в который мы передаем, с чем мы хотим отформатировать, соответственно, текст (Count: {}), а именно `{}` будет замен на первый аргумент. С кнопкой аналогично, но привязка идет именно по команде, то есть ее действие, в данном примере, мы будем просто увеличивать счетчик во viewmodel. [Ссылка на пример - Java](./proto/002_Simple_application_code_ui.java) • [Ссылка на пример - Kotlin](./proto/0021_Simple_application_code_ui.kt)

3. Пример на RML (Rubber Markup Language), в котором создание UI элементов, происходит в RML, все тоже самое что во втором примере, но в RML. Важное примечание `<>` оператор, является оператором привязки (binding). `<` оператор, является оператором односторонней привязки. (Соответственно `>` является односторонней, но в обратную сторону). [Ссылка на пример](./proto/0022_Simple_application_rml_ui.rml)

## Почему Rubber?

Потому что он гибкий, как резина, по крайней мере, планируется таковым существовать и быть. Так как есть возможность, писать на разных JVM языках, использовать с FFI с GraalVM, в т.ч и просто компилировать в native приложение, верстать и стилизовать из yaml, xml, rml и кода. Расширять компоненты и тестировать их, при помощи декорирования.

## Rubber прототипы:

### Kotlin вариант, ([тоже самое](./proto/0011_Simple_application.kt))

```kotlin
fun main(args: Array<String>) {
    Application(
        PrimaryMonitor(
            Monitors(),
            Window(
                WindowCenterPos(),
                WindowAutoSize(),
                WindowTitle("Hello World!"),
                Root(
                    Component(
                        YamlContent("home.yaml"),
                        Stylesheet("home.css"),
                        HomeViewModel()
                    )
                )
            )
        ),
        ApplicationArgs(args)
    ).go()
}
```

### RML (Rubber Markup Language) вариант, ([тоже самое](./proto/0022_Simple_application_rml_ui.rml))

```rust
@declare
    vm ~ com.mairwunnx.home.HomeViewModel

FlexBox
    TextBox
        cssId < "text"
        text <> "Count: {}" vm::count
    Button
        cssId < "increment"
        text < "Increment"
        command > vm::increment
```